input {
  tcp {
    port => 5000
    type => syslog
  }
  udp {
    port => 5000
    type => syslog
  }
  beats {
    port => "5001"
  }
#  stdin { }
}
output {
  elasticsearch { hosts => ["elasticsearch"] }
  #stdout { codec => rubydebug }
}

filter {
if [type] == "perf" {
  #################################################
  ### perf.log
  #################################################
  if [message] =~ "^\w+\s+\|\s+SUCCESS.*$" {
    grok {
      match => { "message" => "%{NOTSPACE:vm} \| %{HOSTNAME:status} \| %{NOTSPACE} >>\s*%{TIMESTAMP_ISO8601:logtime3}\s*\|\s*vm:%{HOSTNAME}\s*\|\s*CPU_used\(%\):%{NUMBER:cpu_used_perc:float}\s*\|\s*RAM_used\(%\):%{NUMBER:ram_used_perc:float}\s*\|\s*SWAP_used\(KB\):%{NUMBER:swap_used_kb:float}\s*\|\s*DISK_used\(%\):%{NUMBER:disk_used_perc:float}" }
    }
    date {
      match => [ "logtime3", "YYYY-MM-dd'T'HH:mm:ssZ" ]
      timezone => "Europe/Paris"
      #locale => "en"
    }
    mutate {
      add_field => { "@source" => "perf" }
      rename    => [ "source" , "file" ]
    }
  }

  elseif [message] =~ "^\w+\s+\|\s+UNREACHABLE!.*$" {
    grok {
      match => { "message" => "%{NOTSPACE:vm} \| %{HOSTNAME:status}%{GREEDYDATA}" }
    }
    mutate {
      add_field => { "@source" => "perf" }
      rename    => [ "source" , "file" ]
    }
  }

  else { drop{} }
}

if [type] == "fail2ban" {
  #################################################
  ### fail2ban.log
  #################################################
  # 2016-05-24 19:41:47,363 fail2ban.filter : INFO   Set maxRetry = 6
  # 2016-05-24 19:45:25,783 fail2ban.actions: WARNING [ssh] Ban 125.212.232.139
  # 2016-09-20 21:50:13,314 fail2ban.filter         [11784]: INFO    [ssh] Found 109.214.187.174   <-- ubuntu16
  if [message] =~ ".*$" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:logtime2} %{WORD}.%{WORD:module}\s*(\[%{INT}\]|): %{WORD:level}\s+%{GREEDYDATA:msg}" }
    }
    date {
      match => [ "logtime2", "YYYY-MM-dd HH:mm:ss,SSS" ]
      timezone => "Europe/Paris"
      #locale => "en"
    }
    mutate {
      add_field => { "@source" => "fail2ban" }
      rename    => [ "source" , "file" ]
      add_field => { "vm" => "zeus" }
    }
  }
  # Ban/unban --> [ssh] Ban 125.212.232.139
  if [msg] =~ "^\[\w+\] \w+ \d+.\d+.\d+.\d+$" {
    grok {
      match => { "msg" => "\[%{WORD:jail}\] %{WORD:action} %{IP:client_ip}" }
    }
    geoip { source => "client_ip" }
  }

}

if [type] == "auth" {
  #################################################
  ### auth.log (ssh access logs)
  #################################################
  # May  9 11:20:05 elk-staging sshd[27491]: Accepted publickey for root from 185.19.29.253 port 39507 ssh2: RSA af:47:3f:c7:6c:17:7a:8f:62:0f:05:bf:d5:d9:75:2f

  if [message] =~ ".*$" {
    grok {
      #match => { "message" => "(?:%{CISCOTIMESTAMP:logtime}) +(?:%{HOSTNAME:vm}|-) +(?:%{WORD:service}|-)(\(%{WORD:service3}\)|)(\[%{HOSTNAME:pid}\]|):( %{NOTSPACE:module}\(%{WORD:service2}:\w+\):|) +(%{GREEDYDATA:msg})" }
       match => { "message" => "(?:%{CISCOTIMESTAMP:logtime1}) +(?:%{HOSTNAME:vm}|-) +(?:%{HOSTNAME:service}|-)(\(%{WORD:service3}\)|)(\[%{HOSTNAME:pid}\]|):( %{NOTSPACE:module}\(%{WORD:service2}:\w+\):|) +(%{GREEDYDATA:msg})" }
    }
    date {
      match => [ "logtime1", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
      timezone => "Europe/Paris"
      #locale => "en"
    }
    mutate {
      add_field => { "@source" => "auth" }
      rename    => [ "source" , "file" ]
    }
  }
  # Google-Auth --> Accepted keyboard-interactive/pam for greg from 185.31.100.144 port 61643 ssh2
  if [msg] =~ "^\w+ keyboard-interactive\/pam for \w+ from \d+.\d+.\d+.\d+ port \d+.*$" {
    grok {
      match => { "msg" => "(?:%{HOSTNAME:status}) (?:%{HOSTNAME:object})\/\w+ for (?:%{USER:user}) from (?:%{IP:client_ip}) port (?:%{POSINT:client_port})" }
    }
  }
  # session as user --> session opened for user root by (uid=0)
  elseif [msg] =~ "^session \w+ for user.*$" {
    grok {
      match => { "msg" => "(?:%{HOSTNAME:object}) +(?:%{HOSTNAME:status}) for user (?:%{HOSTNAME:user})(?: by %{USER:by}|)" }
    }
  }
  # su as user (root) --> Su-Successful su for root by greg
  elseif [msg] =~ "^\w+ su for \w+ by \w+.*$" {
    grok {
      match => { "msg" => "(?:%{HOSTNAME:status}) (?:%{HOSTNAME:object}) for (?:%{USER:user}) by (?:%{USER:by})" }
    }
  }
  # Close connection --> Connection closed by 127.0.0.1 [preauth]
  elseif [msg] =~ "^\w+ \w+ by \d+.\d+.\d+.\d+.*$" {
    grok {
      match => { "msg" => "(?:%{HOSTNAME:object}) +(?:%{HOSTNAME:status}) by (?:%{IP:client_ip}) .*" }
    }
  }
  geoip { source => "client_ip" }
}

#######################
#######################

if [type] == "syslog" {
# nc -w0 -u 192.168.33.10 5000 <<< '<134>Sep 27 01:20:32 haproxy[1]: 172.17.42.1:46563 [26/Sep/2015:21:43:31.697] https-in/1: SSL handshake failure'
# US: 56.42.42.42 ; Paris: 86.217.118.136 ; tokyo: 119.235.235.85

### Copy/paste ######################################

# FIRST PARSING CUT -----------------------------------------------------------------------------------------------

  #################################################
  ### bity.com health via syslog
  #################################################
  #  2016-08-18T21:57:32 vm:elk-staging service:bity.com.health result: HTTP/1.1 200 OK

  if [message] =~ "^\d+-\d+-\d+T\d+:\d+:\d+\svm:\S+\sservice:\S+\smsg:.*$" {
      grok {
        match => { "message" => "%{TIMESTAMP_ISO8601} vm:%{HOSTNAME:vm} service:%{HOSTNAME:service} msg:\s*%{GREEDYDATA:msg}" }
      }
  }

  #################################################
  ### haproxy logs via syslog
  #################################################
  #   <141>Sep 23 12:47:33 haproxy[1]: Proxy https-in started.

  if [message] =~ "<\d+>\w+\s+\d+\s+\d+:\d+:\d+\s+\w+\[\d+\]: .*$" {
      grok {
        match => { "message" => "%{SYSLOG5424PRI}%{CISCOTIMESTAMP} +(?:%{HOSTNAME:container}|-)\[\d\]: +%{GREEDYDATA:msg}" }
      }
  }

  #################################################
  ### Container logs via docker log-driver
  #################################################
  # Old docker format: <131>2016-05-12T13:29:04+02:00 tdengine docker/trader[846]: [2016-05-12 11:29:04,189: INFO/MainProcess] Task liquidities.tasks.execute_liquidity_funding_operations[a321$
  
  #if [message] =~".*db.*" {
  #  drop{}
  #}

  if [message] =~ "^<\d+>\d+-\d+-\d+T\d+:\d+:\d+\+\d+:\d+ \D+ \D+\[\d+\]: .*$" {
    grok {
      match => { "message" => "%{SYSLOG5424PRI}+(?:%{TIMESTAMP_ISO8601:syslog_time1}|-) +(?:%{HOSTNAME:vm}|-) +(\w+/%{NOTSPACE:container}\[\d+\]): +%{GREEDYDATA:msg}" }
    }
  }

  # New docker >1.10 format no RFC: <27>2016-05-12T13:19:23Z backendpublic docker/backendpublic[844]:         "error-text": "Illegal Sender Address - rejected",
  # or old staff                    <14>2016-05-23T00:09:08Z 6a6bad0fcc5c cocky_albattani[1]: /var/lib/postgresql/9.3/main/pg_clog/0024
  if [message] =~ "^<\d+>\d+-\d+-\d+T\d+:\d+:\d+Z \w+ (docker\/|)\w+\[\d+\]: .*$" {
    grok {
      match => { "message" => "%{SYSLOG5424PRI}+(?:%{TIMESTAMP_ISO8601:syslog_time2}|-) +(?:%{HOSTNAME:vm}|-) +((\w+/|)%{NOTSPACE:container}\[\d+\]): +%{GREEDYDATA:msg}" }
    }
  }

  # old format:  <30>May 18 14:02:58 docker/backendadmin[813]: 185.19.28.64 - - [18/May/2016:14:02:58 +0000] "GET /static/grappelli_nested/css/grp_nested_inline.css HTTP/1$
  if [message] =~ "^<\d+>\s*\w+\s+\d+\s\d+:\d+:\d+\s\w+\/\S+\[\d+\]:.*$" {
    grok {
      # match => { "message" => "%{SYSLOG5424PRI} +(?:%{CISCOTIMESTAMP:syslog_time3}|-) +(?:%{HOSTNAME:vm}|-) +(\w+/%{NOTSPACE:container}\[\d+\]): +%{GREEDYDATA:msg}" }
      match => { "message" => "%{SYSLOG5424PRI}+(\s|)+(?:%{CISCOTIMESTAMP:syslog_time4}|-)+(?: %{HOSTNAME:vm}|)+( \w+/%{NOTSPACE:container}\[\d+\]): +%{GREEDYDATA:msg}" }
    }
    #date {
      #match => [ "syslog_time4", "yyyy-MM-dd'T'HH:mm:ss.SSSSSZ+0200", "YYYY-MM-dd'T'HH:mm:ssZ" ]
      #target => "@timestamp"
      #locale => "en"
      #timezone => "UTC"
  }

  # New docker format 1.10 RFC 3164: <30> Apr 27 12:41:10 elk-staging docker/kibana[850]: {"name":"Kibana","hostnam....
  #if [message] =~ "^<\d+>\s*\w+\s+\d+\s\d+:\d+:\d+\s\S+\s\w+\/\S+\[\d+\]:.*$" {
  if [message] =~ "^<\d+>\s*\w+\s+\d+\s\d+:\d+:\d+\s\S+\s\w+(\/\S+|)\[\d+\]:.*$" {
  #else {
    grok {
      #match => { "message" => "%{SYSLOG5424PRI} +(?:%{CISCOTIMESTAMP:syslogtime5}|-)+ (?:%{HOSTNAME:vm} |)+(\w+/%{HOSTNAME:container}\[\d+\]): +%{GREEDYDATA:msg}" }
      match => { "message" => "%{SYSLOG5424PRI} +(?:%{CISCOTIMESTAMP:syslogtime5}|-)+ (?:%{HOSTNAME:vm} |)+((\w+/|)%{HOSTNAME:container}\[\d+\]): +%{GREEDYDATA:msg}" }
    }
    date {
      match => [ "syslogtime5", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
      #target => "@timestamp"
      #locale => "en"
      timezone => "UTC"
      #timezone => "Europe/Paris"
    }
  }

# SECOND PARSING CUT ------------------------------------------------------------------------------------------------



### END Copy/paste ######################################

} # END Loop if

} #END filter
